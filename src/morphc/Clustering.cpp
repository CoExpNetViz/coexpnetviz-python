// Author: Tim Diels <timdiels.m@gmail.com>

#include "Clustering.h"
#include "util.h"
#include <boost/spirit/include/qi.hpp>
#include <boost/function_output_iterator.hpp>
#include <utility>
#include <morphc/TabGrammarRules.h>
#include <morphc/serialization.h>

using namespace std;

namespace MORPHC {

Clustering::Clustering(CONFIG::Clustering clustering_, shared_ptr<GeneExpression> gene_expression_)
:	name(clustering_.get_name()), gene_expression(gene_expression_)
{
	load_bin_or_plain(clustering_.get_path(), *this);
}

void Clustering::load_plain(std::string path) {
	std::vector<size_type> genes;

	// Load
	read_file(path, [this, &genes](const char* begin, const char* end) {
		using namespace boost::spirit::qi;

		std::unordered_map<std::string, Cluster> clusters;

		auto on_cluster_item = [this, &clusters, &genes](const std::vector<std::string>& line) {
			auto gene_name = line.at(0);
			if (!gene_expression->has_gene(gene_name)) {
				// Note: in case clusterings are not generated by us, they might contain genes that we don't know
#ifndef NDEBUG
				cerr << "Warning: gene missing from expression matrix: " << gene_name << endl;
#endif
				return;
			}
			auto cluster_id = line.at(1);
			auto it = clusters.find(cluster_id);
			if (it == clusters.end()) {
				it = clusters.emplace(piecewise_construct, make_tuple(cluster_id), make_tuple(cluster_id)).first;
			}
			auto index = gene_expression->get_gene_index(gene_name);
			it->second.add(index);
			genes.emplace_back(index);
		};

		TabGrammarRules rules;
		parse(begin, end, rules.line[on_cluster_item] % eol);

		// Move clusters' values to this->clusters
		this->clusters.reserve(clusters.size());
		for(auto& p : clusters) {
			this->clusters.emplace_back(std::move(p.second));
		}

		return begin;
	});

	// Group together unclustered genes
	sort(genes.begin(), genes.end());
	clusters.emplace_back(" unclustered"); // the leading space is to avoid accidentally overwriting a cluster in the clustering file named 'unclustered'
	auto& cluster = clusters.back();
	auto& all_genes = gene_expression->get_genes(); // Note: must be ordered
	auto add_to_cluster = boost::make_function_output_iterator([&cluster](const size_type& gene) {
		cluster.add(gene);
	});
	set_difference(all_genes.begin(), all_genes.end(), genes.begin(), genes.end(), add_to_cluster);
	if (cluster.empty()) {
		clusters.pop_back();
	}
}

Clustering::const_iterator Clustering::begin() const {
	return clusters.begin();
}

Clustering::const_iterator Clustering::end() const {
	return clusters.end();
}

GeneExpression& Clustering::get_source() const {
	return *gene_expression;
}

}
